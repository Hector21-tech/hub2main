interface ExportRequest {
  id: string
  title: string
  description: string
  club: string
  position: string | null
  status: string
  priority: string
  createdAt: string
  updatedAt: string
  windowOpenAt?: string | null
  windowCloseAt?: string | null
  deadline?: string | null
  graceDays?: number
}

export class RequestExporter {
  static exportToCSV(requests: ExportRequest[], filename: string = 'scout-requests.csv'): void {
    const headers = [
      'ID',
      'Title',
      'Description',
      'Club',
      'Position',
      'Status',
      'Priority',
      'Window Opens',
      'Window Closes',
      'Deadline',
      'Grace Days',
      'Created At',
      'Updated At'
    ]

    const csvContent = [
      headers.join(','),
      ...requests.map(request => [
        this.escapeCsvField(request.id),
        this.escapeCsvField(request.title),
        this.escapeCsvField(request.description),
        this.escapeCsvField(request.club),
        this.escapeCsvField(request.position || ''),
        this.escapeCsvField(request.status),
        this.escapeCsvField(request.priority),
        this.escapeCsvField(request.windowOpenAt ? new Date(request.windowOpenAt).toLocaleDateString() : ''),
        this.escapeCsvField(request.windowCloseAt ? new Date(request.windowCloseAt).toLocaleDateString() : ''),
        this.escapeCsvField(request.deadline ? new Date(request.deadline).toLocaleDateString() : ''),
        this.escapeCsvField(request.graceDays?.toString() || ''),
        this.escapeCsvField(new Date(request.createdAt).toLocaleDateString()),
        this.escapeCsvField(new Date(request.updatedAt).toLocaleDateString())
      ].join(','))
    ].join('\\n')

    this.downloadFile(csvContent, filename, 'text/csv')
  }

  static exportToJSON(requests: ExportRequest[], filename: string = 'scout-requests.json'): void {
    const jsonContent = JSON.stringify(requests, null, 2)
    this.downloadFile(jsonContent, filename, 'application/json')
  }

  static exportSummaryReport(requests: ExportRequest[], filename: string = 'scout-requests-summary.txt'): void {
    const total = requests.length
    const statusCounts = requests.reduce((acc, req) => {
      acc[req.status] = (acc[req.status] || 0) + 1
      return acc
    }, {} as Record<string, number>)

    const priorityCounts = requests.reduce((acc, req) => {
      acc[req.priority] = (acc[req.priority] || 0) + 1
      return acc
    }, {} as Record<string, number>)

    const clubCounts = requests.reduce((acc, req) => {
      acc[req.club] = (acc[req.club] || 0) + 1
      return acc
    }, {} as Record<string, number>)

    const topClubs = Object.entries(clubCounts)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5)

    const windowStatus = requests.map(req => {
      if (!req.windowOpenAt || !req.windowCloseAt) return 'NO_WINDOW'
      const now = new Date()
      const opensAt = new Date(req.windowOpenAt)
      const closesAt = new Date(req.windowCloseAt)

      if (now < opensAt) return 'OPENS_SOON'
      if (now >= opensAt && now <= closesAt) return 'OPEN'
      return 'CLOSED'
    }).reduce((acc, status) => {
      acc[status] = (acc[status] || 0) + 1
      return acc
    }, {} as Record<string, number>)

    const report = `
SCOUT REQUESTS SUMMARY REPORT
Generated: ${new Date().toLocaleDateString()} ${new Date().toLocaleTimeString()}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ðŸ“Š OVERVIEW
Total Requests: ${total}

ðŸ“ˆ STATUS BREAKDOWN
${Object.entries(statusCounts).map(([status, count]) =>
  `${status}: ${count} (${((count/total)*100).toFixed(1)}%)`
).join('\\n')}

âš¡ PRIORITY BREAKDOWN
${Object.entries(priorityCounts).map(([priority, count]) =>
  `${priority}: ${count} (${((count/total)*100).toFixed(1)}%)`
).join('\\n')}

ðŸ† TOP 5 CLUBS
${topClubs.map(([club, count], index) =>
  `${index + 1}. ${club}: ${count} requests`
).join('\\n')}

ðŸ• TRANSFER WINDOW STATUS
${Object.entries(windowStatus).map(([status, count]) =>
  `${status}: ${count} (${((count/total)*100).toFixed(1)}%)`
).join('\\n')}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ðŸ“‹ DETAILED REQUESTS

${requests.map((req, index) => `
${index + 1}. ${req.title}
   Club: ${req.club}
   Position: ${req.position || 'Not specified'}
   Status: ${req.status} | Priority: ${req.priority}
   Created: ${new Date(req.createdAt).toLocaleDateString()}
   ${req.description ? `Description: ${req.description.substring(0, 100)}${req.description.length > 100 ? '...' : ''}` : ''}
`).join('\\n')}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Report generated by Scout Hub Transfer Management System
    `

    this.downloadFile(report, filename, 'text/plain')
  }

  private static escapeCsvField(field: string): string {
    if (field.includes(',') || field.includes('"') || field.includes('\\n')) {
      return `"${field.replace(/"/g, '""')}"`
    }
    return field
  }

  private static downloadFile(content: string, filename: string, mimeType: string): void {
    const blob = new Blob([content], { type: mimeType })
    const url = window.URL.createObjectURL(blob)

    const link = document.createElement('a')
    link.href = url
    link.download = filename
    link.style.display = 'none'

    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)

    window.URL.revokeObjectURL(url)
  }

  static getExportStats(requests: ExportRequest[]) {
    return {
      total: requests.length,
      statusBreakdown: requests.reduce((acc, req) => {
        acc[req.status] = (acc[req.status] || 0) + 1
        return acc
      }, {} as Record<string, number>),
      priorityBreakdown: requests.reduce((acc, req) => {
        acc[req.priority] = (acc[req.priority] || 0) + 1
        return acc
      }, {} as Record<string, number>),
      dateRange: {
        oldest: requests.reduce((oldest, req) =>
          new Date(req.createdAt) < new Date(oldest.createdAt) ? req : oldest
        )?.createdAt,
        newest: requests.reduce((newest, req) =>
          new Date(req.createdAt) > new Date(newest.createdAt) ? req : newest
        )?.createdAt
      }
    }
  }
}